---
id: nav2
title: "Nav2: Path Planning for Bipedal Movement"
sidebar_label: "Nav2"
sidebar_position: 4
description: "Nav2 stack overview, Costmaps for navigation, Path planners (NavFn, Smac), Behavior trees, Adapting for bipedal robots, Dynamic obstacle avoidance."
keywords: [nav2, ros2, navigation, bipedal, path-planning, behavior-trees]
---

# Nav2: Path Planning for Bipedal Movement

The **Nav2 (Navigation2) stack** is the standard navigation framework in ROS 2, providing a full suite of tools for robots to autonomously navigate complex environments. While Nav2 is commonly used with wheeled or tracked robots, adapting it for bipedal (humanoid) movement presents unique challenges due to their complex locomotion dynamics and balance requirements. This chapter explores the Nav2 stack and how it can be adapted for bipedal robots.

## Nav2 Stack Overview

The Nav2 stack is highly modular and configurable, consisting of several key components that work together:

```mermaid
graph TD
    A[Robot Localization (AMCL/SLAM)] --> B(Global Costmap)
    A --> C(Local Costmap)
    C --> D(Local Planner - TEB/DWA)
    B --> E(Global Planner - NavFn/Smac)
    E --> F(Behavior Tree)
    F --> G(Controller Server)
    G --> H(Robot Base)
    I[Sensor Data (LiDAR, Depth)] --> B
    I --> C
    J[Goal Pose] --> F
    F -- Action / Command --> H
```

-   **Localization**: Estimates the robot's current pose within a map (e.g., AMCL for known maps, SLAM for unknown maps).
-   **Costmaps**: Represent the environment as a grid, indicating obstacles (static and dynamic) and inflated regions around them.
-   **Global Planner**: Computes a collision-free path from the robot's current location to a goal location, typically on a global costmap.
-   **Local Planner/Controller**: Generates velocity commands to follow the global path, avoiding local obstacles, using a local costmap.
-   **Behavior Tree**: Orchestrates the high-level behaviors of the robot, such as navigating to a goal, avoiding obstacles, or recovering from failures.

## Costmaps for Navigation

Nav2 uses two types of costmaps:
-   **Global Costmap**: A large, static map of the entire environment, used by the global planner to find an overall path. It's updated less frequently.
-   **Local Costmap**: A smaller, dynamic map around the robot, used by the local planner to handle immediate obstacles and adjust the robot's trajectory in real-time. It's updated frequently using sensor data.

Costmaps encode information about obstacles, inflation layers (safety margins around obstacles), and unknown areas. For bipedal robots, specific inflation layers might be needed to account for their body shape and swing leg trajectories.

## Path Planners: NavFn, Smac

Nav2 offers various path planners:
-   **NavFn**: A classic global planner using Dijkstra's or A\* algorithm on the costmap.
-   **Smac Planner**: A more modern, optimized planner that can handle differential-drive, omnidirectional, and car-like robots. It can also generate kinematically feasible paths.
-   **Theta\***: An any-angle path planner.

For bipedal robots, the kinematically feasible path generation is critical. Standard planners might not inherently understand bipedal locomotion constraints (e.g., maintaining balance, discrete foot placements).

## Behavior Trees

**Behavior Trees (BTs)** are a powerful tool for designing complex robot behaviors in a modular and hierarchical way. They replace traditional finite-state machines, offering greater flexibility and reusability.

A behavior tree is composed of:
-   **Control Nodes**: (Sequences, Selectors, Parallel) - Define how child nodes are executed.
-   **Decorators**: Modify the behavior of a single child node.
-   **Condition Nodes**: Check for specific conditions (e.g., "Is battery low?", "Is path clear?").
-   **Action Nodes**: Perform a specific action (e.g., "Move to goal", "Grasp object").

### Example: Simple Navigation Behavior Tree

```xml
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <Sequence name="root_sequence">
      <Action ID="ComputePathToGoal"/>
      <Action ID="FollowPath"/>
      <Action ID="ArrivedAtGoal"/>
    </Sequence>
  </BehaviorTree>

  <BehaviorTree ID="ComputePathToGoal">
    <Sequence>
      <Condition ID="GoalAvailable"/>
      <Action ID="CallGlobalPlanner"/>
    </Sequence>
  </BehaviorTree>

  <BehaviorTree ID="FollowPath">
    <Sequence>
      <Condition ID="PathValid"/>
      <Action ID="CallLocalPlanner"/>
    </Sequence>
  </BehaviorTree>
</root>
```

Nav2 uses behavior trees to control the flow between localization, planning, and control.

## Adapting for Bipedal Robots

Adapting Nav2 for bipedal robots requires careful consideration of their unique locomotion characteristics:
-   **Kinematic Constraints**: Bipedal robots have highly constrained movement compared to wheeled robots. Path planners must generate kinematically feasible paths that account for foot placement, swing leg trajectories, and balance.
-   **Dynamic Stability**: Maintaining balance is critical. The local controller must incorporate balance control strategies (e.g., Zero Moment Point (ZMP) control, Center of Mass (CoM) stabilization).
-   **Step-based Planning**: Instead of continuous velocity commands, bipedal locomotion often involves discrete steps. This requires custom local planners or interfaces that convert continuous paths into step plans.
-   **Footstep Planning**: Advanced bipedal navigation might involve a separate footstep planner that determines optimal foot placements.

## Dynamic Obstacle Avoidance

For bipedal robots, avoiding dynamic obstacles (like humans) is even more complex due to their slower response times and balance constraints. Nav2's local planners incorporate dynamic obstacle avoidance, but specific tuning and custom plugins might be necessary for humanoids.

### Example: Nav2 Config and Navigation Client (Conceptual)

This example shows how to configure Nav2 for a bipedal robot and a conceptual Python client to send navigation goals.

**`my_robot_nav/config/bipedal_nav_params.yaml`**
```yaml
local_costmap:
  local_costmap:
    ros__parameters:
      # ... standard local costmap params
      plugins: ["static_layer", "obstacle_layer", "inflation_layer", "bipedal_footprint_layer"]
      bipedal_footprint_layer:
        plugin: "my_robot_nav::BipedalFootprintLayer" # Custom layer to account for bipedal body
        enabled: true
        foot_radius: 0.1 # Example param
        # ...

global_costmap:
  global_costmap:
    ros__parameters:
      # ...

bt_navigator:
  ros__parameters:
    default_bt_xml: "package://my_robot_nav/behavior_trees/bipedal_navigate_to_pose.xml"

controller_server:
  ros__parameters:
    use_interpolation: True
    controller_frequency: 20.0
    progress_checker_plugin: "progress_checker::ProgressChecker"
    goal_checker_plugin: "goal_checker::PrecisionGoalChecker"
    controller_plugins: ["bipedal_controller::BipedalController"] # Custom controller for bipedal
```

**`my_robot_nav/my_robot_nav/bipedal_navigation_client.py` (Conceptual Python client)**
```python
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose

class BipedalNavigationClient(Node):
    def __init__(self):
        super().__init__('bipedal_navigation_client')
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.get_logger().info("Navigation client started. Waiting for action server...")

    def send_goal(self, x, y, yaw):
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.pose.position.x = float(x)
        goal_msg.pose.pose.position.y = float(y)
        
        # Convert yaw to quaternion (simple 2D orientation)
        q = self.euler_to_quaternion(0, 0, float(yaw))
        goal_msg.pose.pose.orientation.x = q[0]
        goal_msg.pose.pose.orientation.y = q[1]
        goal_msg.pose.pose.orientation.z = q[2]
        goal_msg.pose.pose.orientation.w = q[3]

        self._action_client.wait_for_server()
        self.get_logger().info(f"Sending goal: x={x}, y={y}, yaw={yaw}")
        self._send_goal_future = self._action_client.send_goal_async(goal_msg)
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Navigation completed: {result.status}')
        rclpy.shutdown()

    def euler_to_quaternion(self, roll, pitch, yaw):
        # Simplified Euler to Quaternion conversion for yaw only
        cy = np.cos(yaw * 0.5)
        sy = np.sin(yaw * 0.5)
        cp = np.cos(pitch * 0.5)
        sp = np.sin(pitch * 0.5)
        cr = np.cos(roll * 0.5)
        sr = np.sin(roll * 0.5)

        qw = cr * cp * cy + sr * sp * sy
        qx = sr * cp * cy - cr * sp * sy
        qy = cr * sp * cy + sr * cp * sy
        qz = cr * cp * sy - sr * sp * cy
        return [qx, qy, qz, qw]

def main(args=None):
    rclpy.init(args=args)
    nav_client = BipedalNavigationClient()
    nav_client.send_goal(5.0, 3.0, 0.0) # Example: Navigate to (5,3)
    rclpy.spin(nav_client)

if __name__ == '__main__':
    main()
```
This client would be used to programmatically send navigation goals to the Nav2 stack running on the bipedal robot.