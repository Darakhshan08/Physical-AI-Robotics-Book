---
id: locomotion
title: Bipedal Locomotion and Balance Control
sidebar_label: Bipedal Locomotion
sidebar_position: 2
description: Zero Moment Point (ZMP), Center of Mass (CoM) control, Gait generation, Walking pattern generators, Balance recovery, Terrain adaptation.
keywords: [bipedal, locomotion, zmp, com, balance-control, gait]
---

# Bipedal Locomotion and Balance Control

Bipedal locomotion, the act of walking on two legs, is a hallmark of humanoids and presents significant challenges in robotics. Maintaining balance while moving, adapting to uneven terrain, and generating natural gaits requires sophisticated control strategies. This chapter delves into the core concepts of bipedal locomotion, focusing on ZMP, CoM control, and gait generation.

## Zero Moment Point (ZMP)

The **Zero Moment Point (ZMP)** is a crucial concept in bipedal locomotion. It is defined as the point on the ground where the net moment of all forces acting on the robot (including gravity and inertial forces) is zero. If the ZMP stays within the robot's support polygon (the area on the ground defined by the contact points of its feet), the robot will maintain balance. If the ZMP moves outside this polygon, the robot will start to fall.

-   **Support Polygon**: The convex hull of all contact points of the feet with the ground.
-   **ZMP Trajectory**: For stable walking, a robot's controller typically plans a ZMP trajectory that remains within the support polygon throughout the gait cycle.

## Center of Mass (CoM) Control

The **Center of Mass (CoM)** is another critical parameter. The relationship between the CoM and ZMP is fundamental for balance. During walking, the robot continuously shifts its CoM to control the ZMP's position.
-   **CoM Projection**: The projection of the CoM onto the ground plane. For static stability, the CoM projection must also be within the support polygon.
-   **Inverted Pendulum Model**: A common simplification for bipedal walking, where the robot's body is treated as a point mass (CoM) on a massless leg pivoting around the ZMP. This model helps in planning stable CoM trajectories.

```mermaid
graph TD
    A[CoM (Center of Mass)] -->|Controls| B(ZMP (Zero Moment Point))
    B -->|Must be within| C(Support Polygon)
    C -- Ensures --> D[Robot Balance]
```

## Gait Generation

**Gait generation** is the process of creating the sequence of joint movements that result in a walking pattern. For bipedal robots, this is complex and needs to consider:
-   **Stance Phase**: When the foot is in contact with the ground, providing support.
-   **Swing Phase**: When the foot is lifted and moving forward.
-   **Double Support Phase**: When both feet are on the ground (for stable walking).
-   **Single Support Phase**: When only one foot is on the ground.

Gait patterns can be generated using various methods:
-   **Pre-programmed Trajectories**: Simple, but less adaptive.
-   **Pattern Generators**: Mathematical models (e.g., Central Pattern Generators) that produce rhythmic joint movements.
-   **Optimization-based Methods**: Generate gaits that minimize energy consumption or maximize stability.

## Walking Pattern Generators

**Walking pattern generators (WPGs)** are algorithms that produce desired trajectories for the robot's CoM, ZMP, and foot placements to achieve stable walking. A common approach is the Linear Inverted Pendulum Model (LIPM), which simplifies the robot's dynamics to allow for easier real-time trajectory generation.

### Example: Conceptual Gait Generator and Balance Controller Code (Python)

```python
# Conceptual Python code for a simple gait generator and balance controller

import numpy as np

class BipedalController:
    def __init__(self, dt=0.01, robot_height=0.8):
        self.dt = dt  # Time step
        self.robot_height = robot_height # CoM height
        self.g = 9.81 # Gravity
        self.omega = np.sqrt(self.g / self.robot_height) # Natural frequency

        # Current CoM and ZMP state
        self.com_x = 0.0
        self.com_y = 0.0
        self.zmp_x = 0.0
        self.zmp_y = 0.0

        self.foot_pos_left = [-0.1, 0.1, 0.0]  # Initial left foot position (x, y, z)
        self.foot_pos_right = [-0.1, -0.1, 0.0] # Initial right foot position

    def update_com_and_zmp(self, current_com_pos, current_com_vel):
        """
        Updates CoM and ZMP based on simplified dynamics.
        In a real robot, this would come from sensors/state estimator.
        """
        self.com_x = current_com_pos[0]
        self.com_y = current_com_pos[1]
        
        # Simple ZMP calculation (e.g., for inverted pendulum model)
        # Assuming desired ZMP is at current foot contact
        self.zmp_x = self.foot_pos_left[0] if self.is_left_foot_in_contact() else self.foot_pos_right[0]
        self.zmp_y = self.foot_pos_left[1] if self.is_left_foot_in_contact() else self.foot_pos_right[1]

    def generate_gait_step(self, desired_step_length, desired_step_height):
        """
        Conceptual function to generate next foot placement and CoM trajectory.
        This would involve LIPM or other gait generation algorithms.
        """
        self.get_logger().info(f"Generating gait step: length={desired_step_length}, height={desired_step_height}")
        # Placeholder for complex gait generation logic
        # - Plan next ZMP trajectory
        # - Calculate CoM trajectory
        # - Determine swing foot trajectory
        
        # Example: Simple alternating foot placement
        if self.is_left_foot_in_contact():
            # Plan for right foot swing
            self.foot_pos_right[0] += desired_step_length
            self.foot_pos_right[2] = desired_step_height # Lift foot
            self.get_logger().info("Planning right foot swing.")
        else:
            # Plan for left foot swing
            self.foot_pos_left[0] += desired_step_length
            self.foot_pos_left[2] = desired_step_height # Lift foot
            self.get_logger().info("Planning left foot swing.")

        # In a real system, this would output joint angle commands
        return {'left_foot_target': self.foot_pos_left, 'right_foot_target': self.foot_pos_right}

    def control_balance(self, current_com_pos, current_zmp_pos):
        """
        Conceptual balance control law (e.g., PID or LQR for CoM/ZMP).
        """
        error_x = current_com_pos[0] - current_zmp_pos[0]
        error_y = current_com_pos[1] - current_zmp_pos[1]
        
        # Simple proportional control (conceptual)
        correction_force_x = -10.0 * error_x
        correction_force_y = -10.0 * error_y
        
        self.get_logger().info(f"Balance control: CoM error ({error_x:.2f}, {error_y:.2f}) -> Correction ({correction_force_x:.2f}, {correction_force_y:.2f})")
        
        # In a real system, this would translate into ankle/hip torques
        return {'torques_x': correction_force_x, 'torques_y': correction_force_y}

    def is_left_foot_in_contact(self):
        # Placeholder for actual contact sensor logic
        return True # Simulate left foot in contact

    def get_logger(self):
        # Placeholder for logging in a non-ROS context
        import logging
        return logging.getLogger(__name__)

# Example usage (conceptual)
# controller = BipedalController()
# # Simulate main loop
# current_com = [0, 0, 0.8]
# current_zmp = [0, 0, 0] # Assume ZMP at center of feet initially
# for _ in range(10):
#     target_commands = controller.generate_gait_step(0.1, 0.05)
#     balance_commands = controller.control_balance(current_com, current_zmp)
#     # Apply commands to robot, get new state (simulated or real)
#     # current_com, current_zmp = get_new_robot_state_from_sensors()
#     time.sleep(controller.dt)
```

## Balance Recovery

Despite careful planning, external disturbances or unexpected terrain can cause a bipedal robot to lose balance. **Balance recovery** strategies are essential to prevent falls. These can include:
-   **Ankle/Hip Strategies**: Small, quick adjustments to joint torques to shift the CoM.
-   **Step Adjustment**: Taking a quick, unplanned step to widen the support polygon or move the ZMP back into a stable region.
-   **Fall Prevention**: If a fall is inevitable, initiating a controlled fall to minimize damage.

## Terrain Adaptation

Bipedal robots must be able to adapt to various terrains, such as stairs, slopes, or uneven ground. This involves:
-   **Perception**: Using sensors (vision, LiDAR, force sensors) to identify terrain features.
-   **Foot Placement Planning**: Adjusting where the feet are placed to find stable contact points.
-   **Body Pose Adjustment**: Modifying the robot's overall body posture to maintain balance on uneven surfaces.
-   **Compliance**: Implementing compliant control to absorb impacts and conform to terrain irregularities.

These advanced capabilities are often a combination of sophisticated control algorithms, robust perception, and learned policies from reinforcement learning.
