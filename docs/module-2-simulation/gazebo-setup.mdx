---
id: gazebo-setup
title: Gazebo Simulation Environment Setup
sidebar_label: Gazebo Setup
sidebar_position: 1
description: Gazebo Harmonic overview, Installation verification, GUI walkthrough, World files (.sdf), Loading robots, ros_gz_bridge setup.
keywords: [gazebo, simulation, ros2, sdf, ros_gz_bridge]
---

# Gazebo Simulation Environment Setup

Gazebo is a powerful 3D robotics simulator that accurately and efficiently simulates robots in complex indoor and outdoor environments. It's an essential tool for developing and testing robotic applications without the need for physical hardware. We will focus on Gazebo Harmonic, the default version for ROS 2 Humble.

## Gazebo Harmonic Overview

Gazebo Harmonic is a version of Gazebo that is tightly integrated with ROS 2 Humble. It provides:
-   A robust physics engine (ODE, Bullet, DART, Simbody).
-   High-quality graphics and realistic sensor simulation.
-   A user-friendly GUI for visualization and interaction.
-   An extensive collection of models (robots, environments, objects).

## Installation Verification

During the Environment Setup chapter (Chapter 0.4), you would have installed Gazebo Harmonic. You can verify your installation by typing:

```bash
gazebo --version
```
You should see output indicating the Gazebo version (e.g., `Gazebo multi-robot simulator, version X.X.X`).

## GUI Walkthrough

To launch the Gazebo GUI without a specific world:

```bash
gazebo
```

Once launched, you'll see a 3D environment. Key components of the GUI include:
-   **Toolbar**: For adding models, manipulating objects, pausing/resuming simulation.
-   **World Tree**: Lists all entities in the simulation (models, lights, sensors).
-   **Scene Tab**: Controls camera view, lighting, and visual properties.
-   **Console**: Displays messages and warnings from Gazebo.

Spend some time exploring the interface, navigating the 3D world, and adding simple shapes.

## World Files (.sdf)

Gazebo worlds are defined using SDF (Simulation Description Format) files. These XML files describe the environment, including:
-   **Models**: Robots, objects, terrain.
-   **Lights**: Ambient, directional, point lights.
-   **Physics properties**: Gravity, simulation step size.
-   **Sensors**: Cameras, LiDAR, IMUs (can also be part of robot models).

### Example: Simple Gazebo World File

**`my_robot_worlds/empty_world.sdf`**
```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="empty_world">
    <gravity>0 0 -9.8</gravity>
    <scene>
      <ambient>0.4 0.4 0.4 1</ambient>
      <background>0.7 0.7 0.7 1</background>
      <sky>
        <clouds>
          <speed>12</speed>
        </clouds>
      </sky>
    </scene>
    <include>
      <uri>model://sun</uri>
    </include>
    <include>
      <uri>model://ground_plane</uri>
    </include>
  </world>
</sdf>
```

To launch this world:

```bash
gazebo --verbose empty_world.sdf
```
(You might need to specify the full path if `empty_world.sdf` is not in Gazebo's model path.)

## Loading Robots

You can load robot models into Gazebo worlds either directly via the GUI or by specifying them in the SDF world file. For ROS 2 integration, it's common to launch Gazebo and then spawn the robot using a ROS 2 node.

### Example: Spawning a Robot in Gazebo (ROS 2 Launch)

This typically involves a launch file that:
1.  Starts Gazebo with a world.
2.  Launches a `robot_state_publisher` to publish the robot's URDF.
3.  Spawns the robot model into Gazebo using `ros2_gazebo` tools.

**`my_robot_launch/launch/spawn_robot.launch.py`**
```python
import os
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Path to your robot's URDF file
    urdf_file = os.path.join(
        get_package_share_directory('my_robot_description'),
        'urdf',
        'my_robot.urdf'
    )

    # Robot State Publisher Node
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': urdf_file}],
        output='screen'
    )

    # Gazebo launch
    gazebo_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                get_package_share_directory('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ])
    )

    # Spawn robot in Gazebo
    spawn_entity_node = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=['-topic', 'robot_description', '-entity', 'my_robot'],
        output='screen'
    )

    return LaunchDescription([
        gazebo_launch,
        robot_state_publisher_node,
        spawn_entity_node,
    ])
```

## ros_gz_bridge setup

The `ros_gz_bridge` package allows seamless communication between ROS 2 and Gazebo. It bridges Gazebo topics (e.g., sensor data, odometry) to ROS 2 topics, and vice-versa (e.g., sending commands from ROS 2 to Gazebo-controlled robots).

To set up a bridge:

1.  **Install the bridge**:
    ```bash
    sudo apt install ros-humble-ros-gz-bridge
    ```
2.  **Launch a bridge node**: You can use a launch file to configure bridges.

**`my_robot_launch/launch/gz_bridge.launch.py`**
```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='ros_gz_bridge',
            executable='parameter_bridge',
            arguments=[
                '/clock@rosgraph_msgs/msg/Clock[ignition.msgs.Clock',
                '/model/my_robot/joint_state@sensor_msgs/msg/JointState[ignition.msgs.Model',
                # Add more bridges as needed
            ],
            output='screen'
        )
    ])
```
This example bridges the Gazebo clock and joint states to ROS 2.
