---
id: capstone-integration
title: Integration and Testing
sidebar_label: Integration & Testing
sidebar_position: 6
description: System integration steps, Unit testing nodes, Integration testing, Simulation checklist, Performance profiling, Bug tracking.
keywords: [capstone, integration, testing, unit-tests, ros2, simulation]
---

# Integration and Testing

Successfully bringing together all the components of an autonomous humanoid robot (perception, navigation, manipulation, HRI) into a cohesive system requires careful **integration** and rigorous **testing**. This chapter outlines the steps for integrating the various modules developed throughout the book and establishing a comprehensive testing strategy for your Capstone Project.

## System Integration Steps

Integrating a complex robotic system typically follows an iterative approach:

1.  **Bottom-up Integration**: Start by ensuring individual low-level components (e.g., motor drivers, sensor interfaces) work correctly.
2.  **Module-level Integration**: Integrate components within a functional module (e.g., all perception nodes, all navigation nodes).
3.  **Cross-module Integration**: Connect different modules (e.g., navigation output to motion controller input, voice command to planning).
4.  **Full System Integration**: Bring all modules together to demonstrate the robot's complete capabilities.

Key considerations during integration:
-   **Data Flow**: Verify that messages are being published and subscribed to correctly, with the right types and frequencies.
-   **Coordinate Frames**: Ensure all sensor data and commands are in consistent coordinate frames using `tf2`.
-   **Timing and Synchronization**: Pay attention to the timing of operations, especially in real-time systems.

## Unit Testing Nodes

**Unit testing** focuses on verifying the correctness of individual ROS 2 nodes in isolation.
-   **Purpose**: To ensure that each node's logic, message processing, and internal functions work as expected.
-   **Tools**:
    *   **Python**: `pytest` is the standard Python testing framework. `ros2 launch` can run `pytest` tests defined within ROS 2 packages.
    *   **C++**: `gtest` (Google Test) is commonly used.

### Example: Test Cases and Test Launch Config (Conceptual)

This conceptual example shows a Python unit test for a simple ROS 2 node and a launch file to run tests.

**`my_python_package/test/test_my_node.py`**
```python
import pytest
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MyTestNode(Node):
    def __init__(self):
        super().__init__('my_test_node')
        self.subscription = self.create_subscription(
            String,
            '/test_topic',
            self.listener_callback,
            10
        )
        self.received_msg = None

    def listener_callback(self, msg):
        self.received_msg = msg

@pytest.fixture
def minimal_node():
    rclpy.init()
    node = Node('minimal_node')
    yield node
    node.destroy_node()
    rclpy.shutdown()

def test_my_node_publishes_message(minimal_node):
    publisher = minimal_node.create_publisher(String, '/test_topic', 10)
    test_message = String(data='Hello Test!')
    
    # Give some time for publisher and subscriber to connect
    # In a real test, you might use a more robust synchronization method
    rclpy.spin_until_future_complete(minimal_node, publisher.publish(test_message), timeout_sec=1.0)
    
    # Assert that the message was received by the subscriber
    test_subscriber_node = MyTestNode()
    rclpy.spin_once(test_subscriber_node, timeout_sec=1.0) # Check for received message
    
    assert test_subscriber_node.received_msg is not None
    assert test_subscriber_node.received_msg.data == 'Hello Test!'

```

**`my_python_package/launch/test_my_package.launch.py`**
```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import ExecuteProcess
import os

def generate_launch_description():
    package_name = 'my_python_package'
    
    return LaunchDescription([
        Node(
            package=package_name,
            executable='my_test_node', # The node being tested or a test helper node
            name='test_helper_node',
            output='screen',
        ),
        # Run pytest
        ExecuteProcess(
            cmd=['pytest', os.path.join(package_name, 'test')],
            output='screen',
        )
    ])
```
You would run these tests using `ros2 launch my_python_package test_my_package.launch.py`.

## Integration Testing

**Integration testing** verifies that different nodes and modules interact correctly when connected.
-   **Purpose**: To detect interface errors, data flow issues, and incorrect assumptions between components.
-   **Scenarios**: Test specific sequences of actions that involve multiple nodes (e.g., send a navigation goal, verify robot moves and avoids obstacles).
-   **Simulation**: Often performed in simulation (Gazebo or Isaac Sim) to create repeatable and controlled test conditions.

## Simulation Checklist

Before deploying to a real robot, your integrated system should pass a comprehensive simulation checklist:
-   **Basic Functionality**: Does the robot respond to commands?
-   **Navigation**: Can it navigate to targets, avoid static/dynamic obstacles?
-   **Manipulation**: Can it detect, grasp, and place objects?
-   **HRI**: Does it understand voice commands and respond appropriately?
-   **Robustness**: How does it handle ambiguous commands or unexpected events?
-   **Performance**: Is the simulation running in real-time? Are computations within limits?

## Performance Profiling

For real-time robotics, **performance profiling** is crucial to identify bottlenecks.
-   **`ros2 topic hz`**: Check topic publication rates.
-   **`rqt_plot`**: Visualize topic data over time.
-   **`htop` / `nvidia-smi`**: Monitor CPU/GPU usage.
-   **`gprof` / `perf`**: For C++ code profiling.
-   **`cProfile` / `snakeviz`**: For Python code profiling.

## Bug Tracking

A systematic approach to **bug tracking** is essential during integration and testing.
-   **Version Control**: Track all code changes using Git.
-   **Issue Tracker**: Use a platform like GitHub Issues, Jira, or similar to log bugs, assign priorities, and track resolutions.
-   **Clear Descriptions**: Provide detailed bug reports, including steps to reproduce, expected behavior, and observed behavior.
-   **Reproducibility**: Ensure bugs are reproducible for efficient debugging.
