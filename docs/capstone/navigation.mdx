---
id: capstone-navigation
title: Path Planning and Navigation
sidebar_label: Navigation
sidebar_position: 4
description: Environment mapping, Goal pose from commands, Nav2 integration, Obstacle avoidance, Recovery behaviors, Navigation monitoring.
keywords: [capstone, navigation, nav2, mapping, path-planning, obstacle-avoidance]
---

# Path Planning and Navigation

Autonomous navigation is a cornerstone of mobile robotics, enabling robots to move from a starting point to a destination while avoiding obstacles. For a humanoid robot, this involves not just path planning but also maintaining balance and adapting to its unique locomotion capabilities. This chapter details the integration of the Nav2 stack for path planning and navigation within the Capstone Project.

## Environment Mapping

Before a robot can navigate an environment, it needs a map.
-   **SLAM (Simultaneous Localization and Mapping)**: For unknown environments, SLAM algorithms (like those implemented in Cartographer or GMapping, or the visual SLAM in Chapter 3.3) are used to build a map while simultaneously localizing the robot within it.
-   **Pre-built Maps**: For known environments, a static map (e.g., from a CAD drawing or prior SLAM session) can be loaded.
-   **Occupancy Grid Map**: Nav2 typically uses 2D occupancy grid maps (`nav_msgs/msg/OccupancyGrid`), where each cell represents the probability of being occupied by an obstacle.

## Goal Pose from Commands

The voice command processing pipeline (Chapter 5.3) will ultimately output a desired navigation goal. This goal needs to be transformed into a format that Nav2 can understand.
-   **Natural Language to Pose**: An LLM or NLU module interprets commands like "go to the kitchen" or "move next to the red block" and translates them into a `geometry_msgs/msg/PoseStamped` message representing the target position and orientation.
-   **Frame Transformation**: Ensure the goal pose is in the correct coordinate frame (e.g., `map` frame).

## Nav2 Integration

The Nav2 stack (covered in Chapter 3.4) provides the necessary tools for global and local path planning and control.
-   **Global Planner**: Plans a path from the robot's current location to the goal within the global costmap.
-   **Local Planner/Controller**: Executes the global path while avoiding dynamic obstacles in the local costmap, generating velocity commands (for wheeled base) or step plans (for bipedal locomotion).
-   **Behavior Tree**: Orchestrates the navigation process, handling sub-goals like localization, path planning, and obstacle avoidance.

### Example: Navigation Manager and Goal Publisher Code (Conceptual)

This conceptual Python ROS 2 node demonstrates how to send navigation goals to Nav2 and monitor its status.

```python
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose
from std_msgs.msg import String
import json

class NavigationManagerNode(Node):
    def __init__(self):
        super().__init__('navigation_manager_node')
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.command_subscription = self.create_subscription(
            String,
            '/robot/action_command', # From LLM planning pipeline
            self.command_callback,
            10
        )
        self.get_logger().info("Navigation Manager Node started. Waiting for Nav2 action server...")
        self._action_client.wait_for_server()
        self.get_logger().info("Nav2 Action Server is available.")

    def command_callback(self, msg: String):
        """Processes incoming navigation commands."""
        command_data = json.loads(msg.data)
        if command_data.get("action") == "navigate_to_pose":
            params = command_data.get("params")
            if params:
                x = params.get("x", 0.0)
                y = params.get("y", 0.0)
                yaw = params.get("yaw", 0.0)
                self.send_navigation_goal(x, y, yaw)
            else:
                self.get_logger().warn("Navigation command missing parameters.")
        elif command_data.get("action") == "cancel_navigation":
            self.cancel_navigation_goal()

    def send_navigation_goal(self, x, y, yaw):
        """Sends a navigation goal to the Nav2 stack."""
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.pose.position.x = float(x)
        goal_msg.pose.pose.position.y = float(y)
        
        # Convert yaw to quaternion (simple 2D orientation)
        q = self.euler_to_quaternion(0, 0, float(yaw))
        goal_msg.pose.pose.orientation.x = q[0]
        goal_msg.pose.pose.orientation.y = q[1]
        goal_msg.pose.pose.orientation.z = q[2]
        goal_msg.pose.pose.orientation.w = q[3]

        self.get_logger().info(f"Sending navigation goal: x={x}, y={y}, yaw={yaw}")
        self._send_goal_future = self._action_client.send_goal_async(goal_msg)
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Navigation goal rejected :(')
            return

        self.get_logger().info('Navigation goal accepted :)')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Navigation completed with status: {result.status}')
        # Publish feedback or update robot state
        
    def cancel_navigation_goal(self):
        self.get_logger().info('Cancelling navigation goal...')
        if self._send_goal_future and not self._send_goal_future.done():
            goal_handle = self._send_goal_future.result()
            if goal_handle.is_active:
                goal_handle.cancel_goal_async()
        
    def euler_to_quaternion(self, roll, pitch, yaw):
        # Simplified Euler to Quaternion conversion for yaw only
        cy = np.cos(yaw * 0.5)
        sy = np.sin(yaw * 0.5)
        cp = np.cos(pitch * 0.5)
        sp = np.sin(pitch * 0.5)
        cr = np.cos(roll * 0.5)
        sr = np.sin(roll * 0.5)

        qw = cr * cp * cy + sr * sp * sy
        qx = sr * cp * cy - cr * sp * sy
        qy = cr * sp * cy + sr * cp * sy
        qz = cr * cp * sy - sr * sp * cy
        return [qx, qy, qz, qw]

def main(args=None):
    rclpy.init(args=args)
    nav_manager = NavigationManagerNode()
    rclpy.spin(nav_manager)
    nav_manager.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Obstacle Avoidance

For humanoid robots, obstacle avoidance must be robust and adaptive.
-   **Static Obstacles**: Identified from the map and handled by the global planner.
-   **Dynamic Obstacles**: Detected by sensors (e.g., LiDAR, depth camera, human detection nodes) and handled by the local planner, which adjusts the robot's trajectory in real-time.
-   **Human-Aware Navigation**: For humanoids, obstacle avoidance often extends to social navigation, avoiding uncomfortable proximity to humans.

## Recovery Behaviors

Even with robust planning, robots can get into situations where they cannot reach their goal or encounter unexpected obstacles. **Recovery behaviors** are strategies to extract the robot from such situations.
-   **Spin in place**: Rotate to get a new view of the environment.
-   **Backup**: Move backward slightly.
-   **Clear costmap**: Reset the local costmap to remove transient obstacles.
-   **Human intervention**: Request assistance if the robot is stuck.

Nav2's behavior tree allows for defining complex recovery strategies.

## Navigation Monitoring

Continuous monitoring of the navigation stack is crucial for safe and reliable operation.
-   **`rqt_graph`**: Visualize the navigation graph to ensure all nodes are running.
-   **`rviz2`**: Visualize the robot's pose, global path, local trajectory, and costmaps.
-   **Topic Echo**: Monitor relevant topics (e.g., `/cmd_vel`, `/robot_pose`) to check the robot's commands and estimated state.
-   **Status Feedback**: The navigation manager should provide status updates to the higher-level planner or user interface.
