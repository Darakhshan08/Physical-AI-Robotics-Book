---
id: bridging-agents
title: Bridging Python Agents to ROS Controllers
sidebar_label: Bridging Agents
sidebar_position: 6
description: AI Agent architecture, Connecting LLM outputs to ROS 2 actions, Action clients in Python, Message serialization, Real-time considerations, Error handling.
keywords: [ros2, python, agent, llm, action-client, message-serialization]
---

# Bridging Python Agents to ROS Controllers

The true power of Physical AI emerges when intelligent agents, particularly those driven by advanced AI models like Large Language Models (LLMs), can seamlessly interact with and control robotic hardware. This chapter focuses on bridging Python-based AI agents to ROS 2 controllers, enabling high-level reasoning to translate into low-level robot actions.

## AI Agent Architecture

A typical architecture for integrating AI agents with robotic systems involves several layers:

```mermaid
graph TD
    A[Human/High-level Input] --> B[AI Agent (Python)]
    B -- Commands/Plans --> C[ROS 2 Action Client]
    C -- Goal (ROS 2 Action) --> D[ROS 2 Action Server (Robot Controller)]
    D -- Feedback/Status --> C
    D -- Robot Actuation --> E[Robot Hardware]
    E -- Sensor Data --> F[ROS 2 Topics/Sensor Nodes]
    F -- Percepts --> B
```

-   **AI Agent (Python)**: This is the "brain" responsible for high-level reasoning, planning, and decision-making. It could be an LLM, a complex state machine, or a reinforcement learning policy.
-   **ROS 2 Action Client**: The interface that translates the AI agent's high-level commands into structured ROS 2 Action Goals and sends them to the robot controller. It also receives feedback and results.
-   **ROS 2 Action Server (Robot Controller)**: Runs on the robot or an associated compute unit. It receives action goals, executes the necessary low-level control (e.g., inverse kinematics, motor commands), and provides feedback.
-   **Robot Hardware**: The physical actuators and sensors of the robot.
-   **ROS 2 Topics/Sensor Nodes**: Publish real-time sensor data that the AI agent can consume for perception.

## Connecting LLM Outputs to ROS 2 Actions

LLMs excel at understanding natural language and generating coherent responses. The challenge is to convert these textual outputs into actionable robot commands. This typically involves:

1.  **Intent Recognition**: Parsing the LLM's output to identify the robot's intended action (e.g., "pick up the red block", "move forward 1 meter").
2.  **Parameter Extraction**: Extracting relevant parameters for the action (e.g., "red block" as object, "1 meter" as distance).
3.  **Action Mapping**: Mapping the recognized intent and parameters to a specific ROS 2 action type (e.g., `PickAndPlace.action`, `MoveRobot.action`).

## Action Clients in Python

`rclpy` provides robust support for creating ROS 2 action clients. An action client is responsible for sending goals to an action server and receiving updates (feedback) and the final result.

### Example: Simple Action Client

Let's assume we have a `Fibonacci.action` type defined as:
```
# Goal
int32 order
---
# Result
int32[] sequence
---
# Feedback
int32[] partial_sequence
```

**`my_python_package/my_python_package/simple_action_client.py`**
```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

from example_interfaces.action import Fibonacci # Standard action type

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

    def send_goal(self, order):
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()

        self.get_logger().info('Sending goal request...')
        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {list(result.sequence)}')
        rclpy.shutdown()

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Received feedback: {list(feedback.partial_sequence)}')


def main(args=None):
    rclpy.init(args=args)
    action_client = FibonacciActionClient()
    action_client.send_goal(10) # Request 10th Fibonacci number
    rclpy.spin(action_client)


if __name__ == '__main__':
    main()
```

## Message Serialization

When an AI agent (e.g., an LLM running as a separate Python process) needs to send complex data to a ROS 2 action client or receive data from ROS 2 topics, proper message serialization and deserialization are critical.
This involves converting Python objects (like dictionaries, custom classes) into ROS 2 message types and vice-versa.

-   **`json_tricks` or `dataclasses_json`**: For complex Python objects, these libraries can convert them to/from JSON strings, which can then be packed into a ROS 2 `std_msgs/String` message or a custom message type if necessary.
-   **Custom ROS 2 Messages**: For highly structured data, defining custom ROS 2 message types (`.msg` files) is the most robust solution.

## Real-time Considerations

Integrating AI agents, especially LLMs, often introduces latency. For robotic control, real-time performance is crucial.
-   **Asynchronous Communication**: Utilize ROS 2's asynchronous `rclpy` calls for non-blocking communication with action servers.
-   **Dedicated Threads/Processes**: Run computationally intensive AI agents in separate threads or processes to avoid blocking the ROS 2 node's event loop.
-   **Message Queues**: Implement internal queues to handle bursts of data or commands, smoothing the flow between the AI agent and the ROS 2 system.
-   **QoS Settings**: Configure appropriate QoS policies (e.g., `Best Effort` for high-frequency feedback, `Reliable` for critical commands) to optimize communication.

## Error Handling

Robust error handling is paramount when bridging AI agents to physical robots.
-   **Action Server Rejection**: The action server might reject a goal (e.g., invalid parameters, impossible task). The action client must handle `goal_handle.accepted == False`.
-   **Action Preemption**: A higher-priority task might preempt the current action. Action clients must be able to cancel goals and handle preemption feedback.
-   **Communication Failures**: Network issues or node crashes can disrupt communication. Implement timeouts and retries for critical actions.
-   **Robot State Validation**: Before sending a command, the AI agent should ideally validate the current robot state (e.g., joint limits, obstacle presence) to prevent unsafe or impossible actions.
-   **Fallback Behaviors**: Define clear fallback strategies if an AI-generated command cannot be executed or fails (e.g., prompt for human intervention, revert to a safe state).
