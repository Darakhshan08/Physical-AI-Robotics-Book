"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[2092],{7148:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-3-isaac/sim-to-real","title":"Sim-to-Real Transfer Techniques","description":"Reality gap problem, Domain randomization strategies, System identification, Progressive training, Deploying to Jetson, Testing and validation.","source":"@site/docs/module-3-isaac/sim-to-real.mdx","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/sim-to-real","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-3-isaac/sim-to-real","draft":false,"unlisted":false,"editUrl":"https://github.com/Darakhshan08/Physical-AI-Humanoid-Robotics-Textbook/tree/main/docs/module-3-isaac/sim-to-real.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"sim-to-real","title":"Sim-to-Real Transfer Techniques","sidebar_label":"Sim-to-Real Transfer","sidebar_position":6,"description":"Reality gap problem, Domain randomization strategies, System identification, Progressive training, Deploying to Jetson, Testing and validation.","keywords":["sim-to-real","reality-gap","domain-randomization","system-identification","jetson","robotics"]},"sidebar":"tutorialSidebar","previous":{"title":"RL for Robot Control","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-3-isaac/reinforcement-learning"},"next":{"title":"Part 4: Vision-Language-Action - VLA","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/category/part-4-vision-language-action---vla"}}');var t=i(4848),r=i(8453);const s={id:"sim-to-real",title:"Sim-to-Real Transfer Techniques",sidebar_label:"Sim-to-Real Transfer",sidebar_position:6,description:"Reality gap problem, Domain randomization strategies, System identification, Progressive training, Deploying to Jetson, Testing and validation.",keywords:["sim-to-real","reality-gap","domain-randomization","system-identification","jetson","robotics"]},a="Sim-to-Real Transfer Techniques",l={},c=[{value:"Reality Gap Problem",id:"reality-gap-problem",level:2},{value:"Domain Randomization Strategies",id:"domain-randomization-strategies",level:2},{value:"System Identification",id:"system-identification",level:2},{value:"Progressive Training",id:"progressive-training",level:2},{value:"Deploying to Jetson",id:"deploying-to-jetson",level:2},{value:"Example: Model Export and Deployment Script (Conceptual)",id:"example-model-export-and-deployment-script-conceptual",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"sim-to-real-transfer-techniques",children:"Sim-to-Real Transfer Techniques"})}),"\n",(0,t.jsxs)(n.p,{children:["One of the greatest challenges in robotics is successfully transferring policies and models trained in simulation to real-world robots. This is known as the ",(0,t.jsx)(n.strong,{children:"sim-to-real transfer"}),' problem. The discrepancy between simulation and reality, often called the "reality gap," can lead to trained models performing poorly or failing entirely when deployed on physical hardware. This chapter explores common techniques to bridge this gap, focusing on methods relevant for humanoid robots.']}),"\n",(0,t.jsx)(n.h2,{id:"reality-gap-problem",children:"Reality Gap Problem"}),"\n",(0,t.jsx)(n.p,{children:"The reality gap arises from various factors:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modeling Errors"}),": Imperfect physics models (friction, contact, elasticity), inaccurate sensor models (noise, calibration), and simplified actuator models."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unaccounted Dynamics"}),": Factors like cable compliance, motor backlash, or slight inaccuracies in robot dimensions that are difficult to model accurately."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Noise Differences"}),": The statistical properties of noise in simulated sensors may not perfectly match real sensors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visual Discrepancies"}),": Differences in lighting, textures, and material properties between simulation and reality."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Bridging this gap is crucial for efficient development, as it allows for safer, faster, and cheaper training in simulation before deploying to expensive and fragile real robots."}),"\n",(0,t.jsx)(n.h2,{id:"domain-randomization-strategies",children:"Domain Randomization Strategies"}),"\n",(0,t.jsxs)(n.p,{children:["As discussed in Chapter 3.2, ",(0,t.jsx)(n.strong,{children:"domain randomization"})," is a primary technique to tackle the reality gap. Instead of trying to make the simulation perfectly match reality, it deliberately randomizes various aspects of the simulation to make the trained policy robust to variations."]}),"\n",(0,t.jsx)(n.p,{children:"For sim-to-real, important randomization parameters include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Physics Properties"}),": Randomize friction coefficients, mass, inertia, joint limits, and motor strengths."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sensor Properties"}),": Randomize camera intrinsics/extrinsics, sensor noise levels, and latency."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visual Properties"}),": Randomize textures, lighting, object colors, and background environments."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot Parameters"}),": Varying the robot's dimensions, center of mass, or joint stiffness within plausible ranges."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The goal is to teach the agent to focus on the essential features of the task rather than memorizing specifics of the simulation environment."}),"\n",(0,t.jsx)(n.h2,{id:"system-identification",children:"System Identification"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"System identification"})," is the process of using experimental data from a real robot to build or refine a mathematical model of its dynamics. This can help to narrow the reality gap by making the simulation's physics more closely match the real robot's behavior."]}),"\n",(0,t.jsx)(n.p,{children:"Techniques include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Estimation"}),": Estimating physical parameters like mass, inertia, and friction coefficients from observed robot movements."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Model Calibration"}),": Adjusting simulation parameters based on real-world sensor data."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"progressive-training",children:"Progressive Training"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Progressive training"})," involves gradually increasing the complexity or realism of the simulation during the training process."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Curriculum Learning"}),": Start training in a simpler, less randomized simulation, and as the agent learns, gradually introduce more randomization or more complex tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transfer Learning"}),": Fine-tune a policy pre-trained in a highly randomized simulation on a small amount of real-world data, or on a more accurate simulation of the specific target robot."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deploying-to-jetson",children:"Deploying to Jetson"}),"\n",(0,t.jsx)(n.p,{children:"Once a policy or model is trained in simulation, it needs to be deployed to the target robotic hardware, often an NVIDIA Jetson platform for edge AI. This typically involves:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Model Export"}),": Exporting the trained neural network (e.g., from PyTorch or TensorFlow) into an optimized inference format (e.g., ONNX, TensorRT)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Integration"}),": Packaging the inference engine and associated control logic into a ROS 2 node, leveraging Isaac ROS for hardware acceleration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Containerization"}),": Using Docker or other container technologies to ensure a consistent deployment environment on the Jetson."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-model-export-and-deployment-script-conceptual",children:"Example: Model Export and Deployment Script (Conceptual)"}),"\n",(0,t.jsx)(n.p,{children:"This conceptual example outlines the steps to export a trained RL policy and deploy it."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Conceptual Python script for exporting a trained RL policy to ONNX/TensorRT\r\n\r\nimport torch\r\nimport torch.onnx\r\n# import onnxruntime # For ONNX inference\r\n# import tensorrt # For TensorRT optimization\r\n\r\n# Assume 'policy_model' is your trained PyTorch policy\r\n# policy_model = MyActorPolicy()\r\n# policy_model.load_state_dict(torch.load(\"trained_policy.pth\"))\r\n# policy_model.eval()\r\n\r\n# Dummy input to trace the model (replace with actual observation space)\r\ndummy_input = torch.randn(1, observation_space_dim) \r\n\r\n# Export to ONNX (conceptual)\r\n# torch.onnx.export(policy_model,\r\n#                   dummy_input,\r\n#                   \"exported_policy.onnx\",\r\n#                   opset_version=11,\r\n#                   input_names=['input'],\r\n#                   output_names=['output'],\r\n#                   dynamic_axes={'input': {0: 'batch_size'}, 'output': {0: 'batch_size'}})\r\n\r\n# Conceptual deployment script for Jetson\r\n# This would involve copying the ONNX/TensorRT model to the Jetson\r\n# and running an Isaac ROS node that loads this model for inference.\r\n\r\n\"\"\"\r\n# Example (conceptual) deployment on Jetson:\r\n\r\n# 1. Copy model to Jetson:\r\nscp exported_policy.onnx user@jetson_ip:/home/user/robot_control/\r\n\r\n# 2. On Jetson, run an Isaac ROS inference node:\r\n# This node would:\r\n# - Subscribe to sensor data (observations)\r\n# - Load the exported_policy.onnx (or TensorRT engine)\r\n# - Perform inference to get actions\r\n# - Publish commands to robot controllers\r\n# - Potentially interact with a custom ROS 2 action server for high-level tasks\r\n\r\n# Example launch on Jetson (conceptual):\r\nros2 launch my_robot_control_package deployed_policy_launch.py\r\n\"\"\"\r\nprint(\"Conceptual policy export and deployment steps outlined.\")\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,t.jsx)(n.p,{children:"Post-deployment, rigorous testing and validation are essential:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unit Testing"}),": Verify individual components (e.g., sensor interfaces, motor drivers)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration Testing"}),": Check end-to-end functionality of the deployed system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-world Evaluation"}),": Evaluate the robot's performance in its intended environment, comparing it against simulation results."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safety Protocols"}),": Ensure the deployed policy operates safely and predictably."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring"}),": Continuously monitor the robot's behavior and performance."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Sim-to-real transfer is an iterative process, often requiring adjustments to both simulation and real-world deployment strategies."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var o=i(6540);const t={},r=o.createContext(t);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);