"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6994],{3816:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-simulation/physics-simulation","title":"Simulating Physics, Gravity, and Collisions","description":"Physics engines (DART, Bullet, ODE), Gravity configuration, Collision detection, Friction and contact parameters, Inertia calculations, Physics step size.","source":"@site/docs/module-2-simulation/physics-simulation.mdx","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/physics-simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-simulation/physics-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Darakhshan08/Physical-AI-Humanoid-Robotics-Textbook/tree/main/docs/module-2-simulation/physics-simulation.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"physics-simulation","title":"Simulating Physics, Gravity, and Collisions","sidebar_label":"Physics Simulation","sidebar_position":3,"description":"Physics engines (DART, Bullet, ODE), Gravity configuration, Collision detection, Friction and contact parameters, Inertia calculations, Physics step size.","keywords":["gazebo","physics","simulation","gravity","collisions","friction"]},"sidebar":"tutorialSidebar","previous":{"title":"URDF & SDF","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-simulation/urdf-sdf"},"next":{"title":"Sensor Simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-2-simulation/sensor-simulation"}}');var t=n(4848),r=n(8453);const o={id:"physics-simulation",title:"Simulating Physics, Gravity, and Collisions",sidebar_label:"Physics Simulation",sidebar_position:3,description:"Physics engines (DART, Bullet, ODE), Gravity configuration, Collision detection, Friction and contact parameters, Inertia calculations, Physics step size.",keywords:["gazebo","physics","simulation","gravity","collisions","friction"]},l="Simulating Physics, Gravity, and Collisions",a={},c=[{value:"Physics Engines: DART, Bullet, ODE",id:"physics-engines-dart-bullet-ode",level:2},{value:"Gravity Configuration",id:"gravity-configuration",level:2},{value:"Collision Detection",id:"collision-detection",level:2},{value:"Friction and Contact Parameters",id:"friction-and-contact-parameters",level:2},{value:"Example: Physics Configuration XML",id:"example-physics-configuration-xml",level:3},{value:"Inertia Calculations",id:"inertia-calculations",level:2},{value:"Physics Step Size",id:"physics-step-size",level:2}];function d(i){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...i.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"simulating-physics-gravity-and-collisions",children:"Simulating Physics, Gravity, and Collisions"})}),"\n",(0,t.jsx)(e.p,{children:"Accurate physics simulation is at the heart of any realistic robotics simulation. Gazebo provides a powerful physics engine that allows you to model how robots interact with their environment, including gravity, collisions, and various physical properties."}),"\n",(0,t.jsx)(e.h2,{id:"physics-engines-dart-bullet-ode",children:"Physics Engines: DART, Bullet, ODE"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo supports several physics engines, each with its strengths and weaknesses:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": The default engine for many Gazebo versions. It's stable and well-tested."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bullet"}),": A popular open-source physics engine used in many games and simulations. Known for robust collision detection."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Optimized for robotics, DART excels in simulating complex articulated bodies and contact dynamics."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simbody"}),": A high-performance, multi-body dynamics library suitable for biomechanics and robotics."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"You can select the physics engine in your Gazebo world file."}),"\n",(0,t.jsx)(e.h2,{id:"gravity-configuration",children:"Gravity Configuration"}),"\n",(0,t.jsx)(e.p,{children:"Gravity is a fundamental force in any realistic simulation. In Gazebo, you can configure the gravity vector within your SDF world file. The default is typically Earth's gravity (-9.8 m/s\xb2 in the Z-direction)."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<world name="my_world">\r\n  <gravity>0 0 -9.8</gravity> \x3c!-- Earth\'s gravity in negative Z direction --\x3e\r\n  \x3c!-- ... other world elements ... --\x3e\r\n</world>\n'})}),"\n",(0,t.jsx)(e.p,{children:"You can also set custom gravity values to simulate different planets or scenarios."}),"\n",(0,t.jsx)(e.h2,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,t.jsx)(e.p,{children:"Collision detection is the process of identifying when two or more objects in the simulation intersect. This is crucial for preventing interpenetration and triggering contact responses."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.code,{children:"<collision>"})," tag in URDF/SDF"]}),": Defines the geometric shape used for collision detection for a link. This geometry is often simplified (e.g., a bounding box or cylinder) compared to the visual mesh to improve performance."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Collision Pair"}),': When two collision geometries intersect, a "collision pair" is registered.']}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:"graph LR\r\n    A[Visual Mesh] -- For rendering --\x3e G[Robot Link]\r\n    B[Collision Mesh] -- For physics interactions --\x3e G\r\n\r\n    G -- Intersects with --\x3e C[Environment Object]\r\n    C -- Leads to --\x3e D[Collision Event]\n"})}),"\n",(0,t.jsx)(e.h2,{id:"friction-and-contact-parameters",children:"Friction and Contact Parameters"}),"\n",(0,t.jsxs)(e.p,{children:["When objects collide, their interaction involves friction. Gazebo allows you to define various contact parameters within the ",(0,t.jsx)(e.code,{children:"<surface>"})," tag of a link's collision properties:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<friction>"})}),": Defines static and dynamic friction coefficients (",(0,t.jsx)(e.code,{children:"mu1"}),", ",(0,t.jsx)(e.code,{children:"mu2"}),") for sliding friction, and optional torsional friction."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<contact>"})}),": Configures contact properties like stiffness, damping, and maximum depth for penetration."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-physics-configuration-xml",children:"Example: Physics Configuration XML"}),"\n",(0,t.jsx)(e.p,{children:"This example demonstrates configuring physics parameters in a Gazebo world file, including engine selection and contact properties."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.7">\r\n  <world name="friction_test_world">\r\n    <plugin name="ignition::gazebo::systems::Physics" filename="ignition-gazebo-physics-system"/>\r\n    <gravity>0 0 -9.8</gravity>\r\n\r\n    <physics name="default_physics" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n      <ode>\r\n        <solver>\r\n          <type>quick</type>\r\n          <iters>50</iters>\r\n          <precon_iters>0</precon_iters>\r\n          <sor>1.3</sor>\r\n          <erp>0.2</erp>\r\n          <cfm>0</cfm>\r\n          <split_impulse>true</split_impulse>\r\n          <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>\r\n        </solver>\r\n        <constraints>\r\n          <cfm>0</cfm>\r\n          <erp>0.2</erp>\r\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n          <contact_surface_layer>0.001</contact_surface_layer>\r\n        </constraints>\r\n      </ode>\r\n    </physics>\r\n\r\n    \x3c!-- Example Model with Custom Friction --\x3e\r\n    <model name="sliding_block">\r\n      <link name="block_link">\r\n        <collision name="collision">\r\n          <geometry><box><size>0.1 0.1 0.1</size></box></geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>1.0</mu>\r\n                <mu2>1.0</mu2>\r\n                <fdir1>0 0 0</fdir1>\r\n                <slip1>0</slip1>\r\n                <slip2>0</slip2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry><box><size>0.1 0.1 0.1</size></box></geometry>\r\n          <material><script><uri>file://media/materials/scripts/gazebo.material</uri><name>Gazebo/Green</name><\/script></material>\r\n        </visual>\r\n        <inertial>\r\n          <mass>1.0</mass>\r\n          <inertia><ixx>0.001</ixx><ixy>0</ixy><ixz>0</ixz><iyy>0.001</iyy><iyz>0</iyz><izz>0.001</izz></inertia>\r\n        </inertial>\r\n      </link>\r\n      <pose>0 0 0.5 0 0 0</pose>\r\n    </model>\r\n\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n    <include>\r\n      <uri>model://sun</uri>\r\n    </include>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"inertia-calculations",children:"Inertia Calculations"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Inertial properties"})," (mass, center of mass, and inertia tensor) are critical for accurate dynamic simulation. The ",(0,t.jsx)(e.code,{children:"<inertial>"})," tag within a link defines these properties."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"mass"})}),": Total mass of the link in kilograms."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"origin"})}),": Center of mass of the link, relative to the link's origin."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"inertia"})}),": A 3x3 symmetric matrix representing the moment of inertia tensor. For simple geometries, Gazebo can automatically calculate this if not provided, but for complex shapes, it's best to compute them using CAD software."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"physics-step-size",children:"Physics Step Size"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:"physics step size"})," (",(0,t.jsx)(e.code,{children:"max_step_size"}),") defines the discrete time interval used by the physics engine to advance the simulation."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Smaller step size"}),": More accurate simulation, but computationally more expensive and slower."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Larger step size"}),": Faster simulation, but can lead to instabilities or inaccurate results, especially for fast-moving or colliding objects."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["You can configure ",(0,t.jsx)(e.code,{children:"max_step_size"})," and ",(0,t.jsx)(e.code,{children:"real_time_update_rate"})," in the ",(0,t.jsx)(e.code,{children:"<physics>"})," tag of your world file to balance accuracy and simulation speed."]})]})}function h(i={}){const{wrapper:e}={...(0,r.R)(),...i.components};return e?(0,t.jsx)(e,{...i,children:(0,t.jsx)(d,{...i})}):d(i)}},8453:(i,e,n)=>{n.d(e,{R:()=>o,x:()=>l});var s=n(6540);const t={},r=s.createContext(t);function o(i){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function l(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(t):i.components||t:o(i.components),s.createElement(r.Provider,{value:e},i.children)}}}]);