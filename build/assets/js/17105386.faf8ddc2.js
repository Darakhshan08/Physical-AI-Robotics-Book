"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[4866],{8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},8724:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vla/kinematics","title":"Humanoid Robot Kinematics and Dynamics","description":"Forward kinematics, Inverse kinematics (IK), Denavit-Hartenberg parameters, Dynamics (Forces and torques), PyBullet simulation, IK solvers (KDL, TRAC-IK).","source":"@site/docs/module-4-vla/kinematics.mdx","sourceDirName":"module-4-vla","slug":"/module-4-vla/kinematics","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-4-vla/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/Darakhshan08/Physical-AI-Humanoid-Robotics-Textbook/tree/main/docs/module-4-vla/kinematics.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"kinematics","title":"Humanoid Robot Kinematics and Dynamics","sidebar_label":"Kinematics & Dynamics","sidebar_position":1,"description":"Forward kinematics, Inverse kinematics (IK), Denavit-Hartenberg parameters, Dynamics (Forces and torques), PyBullet simulation, IK solvers (KDL, TRAC-IK).","keywords":["robotics","kinematics","dynamics","humanoid","pybullet","ik"]},"sidebar":"tutorialSidebar","previous":{"title":"Part 4: Vision-Language-Action - VLA","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/category/part-4-vision-language-action---vla"},"next":{"title":"Bipedal Locomotion","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module-4-vla/locomotion"}}');var o=i(4848),r=i(8453);const s={id:"kinematics",title:"Humanoid Robot Kinematics and Dynamics",sidebar_label:"Kinematics & Dynamics",sidebar_position:1,description:"Forward kinematics, Inverse kinematics (IK), Denavit-Hartenberg parameters, Dynamics (Forces and torques), PyBullet simulation, IK solvers (KDL, TRAC-IK).",keywords:["robotics","kinematics","dynamics","humanoid","pybullet","ik"]},a="Humanoid Robot Kinematics and Dynamics",l={},c=[{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Inverse Kinematics (IK)",id:"inverse-kinematics-ik",level:2},{value:"Denavit-Hartenberg Parameters",id:"denavit-hartenberg-parameters",level:2},{value:"Dynamics: Forces and Torques",id:"dynamics-forces-and-torques",level:2},{value:"PyBullet Simulation",id:"pybullet-simulation",level:2},{value:"Example: FK Calculation, IK Solver, PyBullet Setup (Conceptual)",id:"example-fk-calculation-ik-solver-pybullet-setup-conceptual",level:3},{value:"IK Solvers: KDL, TRAC-IK",id:"ik-solvers-kdl-trac-ik",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-robot-kinematics-and-dynamics",children:"Humanoid Robot Kinematics and Dynamics"})}),"\n",(0,o.jsx)(e.p,{children:"Understanding the kinematics and dynamics of a humanoid robot is fundamental to controlling its movements, planning trajectories, and simulating its interactions with the environment. Kinematics describes the geometry of motion without considering the forces that cause it, while dynamics deals with the relationship between forces and motion."}),"\n",(0,o.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Forward kinematics (FK)"})," is the process of calculating the position and orientation (pose) of an end-effector (e.g., a robot's hand or foot) in 3D space, given the joint angles (or positions) of the robot's arm or leg."]}),"\n",(0,o.jsx)(e.p,{children:"For a serial chain robot, FK is typically computed by sequentially applying transformation matrices (rotation and translation) from the base frame to each subsequent joint, until the end-effector frame is reached."}),"\n",(0,o.jsx)(e.h2,{id:"inverse-kinematics-ik",children:"Inverse Kinematics (IK)"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Inverse kinematics (IK)"})," is the inverse problem: calculating the required joint angles to achieve a desired end-effector pose. IK is significantly more complex than FK because:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multiple Solutions"}),": There might be multiple sets of joint angles that result in the same end-effector pose."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"No Solution"}),": The desired pose might be unreachable (outside the robot's workspace)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Computational Cost"}),": Solving IK often involves iterative numerical methods."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, IK is essential for tasks like reaching for objects, stepping onto specific locations, or maintaining balance."}),"\n",(0,o.jsx)(e.h2,{id:"denavit-hartenberg-parameters",children:"Denavit-Hartenberg Parameters"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Denavit-Hartenberg (DH) parameters"})," are a widely used convention for systematically representing the kinematic structure of robotic manipulators. A set of four parameters (a, \u03b1, d, \u03b8) uniquely describes the relationship between two consecutive links in a serial chain."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TD\r\n    A[Link i-1] --\x3e|a_i-1, &#x03B1;_i-1| J_i-1[Joint i-1]\r\n    J_i-1 --\x3e|d_i, &#x03B8;_i| L_i[Link i]\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"a"}),": The length of the common normal between joint axes."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"\u03b1"}),": The angle between joint axes about the common normal."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"d"}),": The distance along the joint axis."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"\u03b8"}),": The angle between common normals."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"dynamics-forces-and-torques",children:"Dynamics: Forces and Torques"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Dynamics"})," deals with the relationship between the forces and torques acting on a robot and its resulting motion (acceleration). This is critical for:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Trajectory Tracking"}),": Calculating the motor torques required to follow a planned trajectory."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Force Control"}),": Interacting with the environment with a desired force."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance Control"}),": Maintaining stability for bipedal robots against gravity and external disturbances."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Key concepts in dynamics include:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mass and Inertia"}),": Properties of links."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gravity"}),": Force acting on the robot's mass."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"External Forces/Torques"}),": Interactions with the environment."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joint Torques"}),": Forces applied by motors."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"pybullet-simulation",children:"PyBullet Simulation"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"PyBullet"})," is a Python module for the Bullet Physics SDK, offering fast and accurate physics simulation. It's an excellent tool for:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Robot Simulation"}),": Loading URDF/SDF models and simulating their dynamics."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Kinematics"}),": Computing FK and solving IK."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Reinforcement Learning"}),": Interfacing with RL environments."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-fk-calculation-ik-solver-pybullet-setup-conceptual",children:"Example: FK Calculation, IK Solver, PyBullet Setup (Conceptual)"}),"\n",(0,o.jsx)(e.p,{children:"This conceptual Python code demonstrates basic PyBullet setup, forward kinematics, and inverse kinematics."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import pybullet as p\r\nimport pybullet_data\r\nimport time\r\nimport numpy as np\r\n\r\n# 1. PyBullet Setup\r\nphysicsClient = p.connect(p.GUI) # or p.DIRECT for non-graphical version\r\np.setAdditionalSearchPath(pybullet_data.getDataPath())\r\np.setGravity(0, 0, -9.81) # Earth\'s gravity\r\n\r\n# Load a robot model (e.g., a simplified humanoid or manipulator)\r\n# Replace \'r2d2.urdf\' with your humanoid\'s URDF path\r\nrobot = p.loadURDF("r2d2.urdf", useFixedBase=True)\r\n\r\n# Get number of joints\r\nnum_joints = p.getNumJoints(robot)\r\nprint(f"Robot has {num_joints} joints.")\r\n\r\n# Get joint info and find controllable joints\r\ncontrollable_joints = []\r\nfor i in range(num_joints):\r\n    joint_info = p.getJointInfo(robot, i)\r\n    joint_type = joint_info[2]\r\n    if joint_type == p.JOINT_REVOLUTE or joint_type == p.JOINT_PRISMATIC:\r\n        controllable_joints.append(i)\r\n        print(f"Joint {i}: {joint_info[1].decode(\'UTF-8\')}, Type: {joint_type}")\r\n\r\n# 2. Forward Kinematics (Conceptual)\r\n# Let\'s say we want the pose of a specific end-effector link (e.g., a hand)\r\nend_effector_link_index = 6 # Example link index, needs to be found for your robot\r\n\r\n# Get the current state of the end-effector\r\n# This is essentially FK: given current joint positions, what\'s the EE pose?\r\nlink_state = p.getLinkState(robot, end_effector_link_index)\r\nee_position = link_state[0]\r\nee_orientation = link_state[1] # Quaternion\r\nprint(f"End-effector position (FK): {np.round(ee_position, 3)}")\r\n\r\n# 3. Inverse Kinematics Solver (Conceptual)\r\n# Target end-effector position and orientation\r\ntarget_position = [0.5, 0.5, 0.5]\r\ntarget_orientation = p.getQuaternionFromEuler([0, 0, 0]) # Example: zero orientation\r\n\r\n# Use IK solver to find joint angles\r\nmax_iterations = 100\r\ndamping_ratio = 0.01 # Damping helps with singularity avoidance\r\n\r\njoint_dofs = [] # Degrees of freedom for each controllable joint\r\njoint_ranges = [] # Joint limits\r\n\r\n# Populate joint_dofs and joint_ranges based on your robot\'s URDF\r\nfor joint_idx in controllable_joints:\r\n    joint_info = p.getJointInfo(robot, joint_idx)\r\n    joint_lower_limit = joint_info[8]\r\n    joint_upper_limit = joint_info[9]\r\n    joint_ranges.append(joint_upper_limit - joint_lower_limit) # Range for that joint\r\n    joint_dofs.append(1) # Assuming 1 DOF per revolute/prismatic joint\r\n\r\n# Simplified IK - requires setting correct maxForce and maxVelocity for each joint\r\nsolved_joint_positions = p.calculateInverseKinematics(\r\n    robot,\r\n    end_effector_link_index,\r\n    target_position,\r\n    targetOrientation=target_orientation,\r\n    lowerLimits=[jl[0] for jl in p.getJointInfo(robot, j) for j in controllable_joints], # Example, replace with actual\r\n    upperLimits=[jl[1] for jl in p.getJointInfo(robot, j) for j in controllable_joints], # Example, replace with actual\r\n    jointRanges=joint_ranges,\r\n    restPoses=[0.0] * len(controllable_joints), # Rest pose for the joints\r\n    jointDamping=[0.1] * len(controllable_joints)\r\n)\r\n\r\n# Apply solved joint positions\r\n# for i, joint_idx in enumerate(controllable_joints):\r\n#     p.setJointMotorControl2(robot, joint_idx, p.POSITION_CONTROL, targetPosition=solved_joint_positions[i])\r\n\r\nprint(f"Target position: {target_position}")\r\nprint(f"Solved joint positions (IK): {np.round(solved_joint_positions, 3)}")\r\n\r\n\r\n# Keep simulation running for visualization\r\n# while p.isConnected():\r\n#     p.stepSimulation()\r\n#     time.sleep(1./240.)\r\n\r\n# p.disconnect()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"ik-solvers-kdl-trac-ik",children:"IK Solvers: KDL, TRAC-IK"}),"\n",(0,o.jsx)(e.p,{children:"For more complex robots and real-time applications, dedicated IK libraries offer optimized and robust solutions:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"KDL (Kinematics and Dynamics Library)"}),": A C++ library (with Python bindings) often used in ROS for kinematics. It's fast and handles various joint types."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"TRAC-IK"}),": A C++-based IK solver optimized for speed and collision avoidance, especially useful for redundant manipulators. It integrates with KDL."]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["These solvers are integrated into ROS 2 through packages like ",(0,o.jsx)(e.code,{children:"moveit_kinematics"}),", providing services that a Python agent can call to solve IK."]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);